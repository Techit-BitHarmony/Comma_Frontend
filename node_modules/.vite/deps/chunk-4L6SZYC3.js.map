{
  "version": 3,
  "sources": ["../../svelte/src/main/main-client.js"],
  "sourcesContent": ["import {\n\tcurrent_component_context,\n\tdestroy_signal,\n\tget_or_init_context_map,\n\tis_ssr,\n\tmanaged_effect,\n\tuntrack,\n\tuser_effect,\n\tflush_local_render_effects\n} from '../internal/client/runtime.js';\nimport { is_array } from '../internal/client/utils.js';\n\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.\n *\n * `onMount` does not run inside a [server-side component](https://svelte.dev/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs/svelte#onmount\n * @template T\n * @param {() => import('./private.js').NotFunction<T> | Promise<import('./private.js').NotFunction<T>> | (() => any)} fn\n * @returns {void}\n */\nexport function onMount(fn) {\n\tif (!is_ssr) {\n\t\tuser_effect(() => {\n\t\t\tconst result = untrack(fn);\n\t\t\tif (typeof result === 'function') {\n\t\t\t\treturn /** @type {() => any} */ (result);\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#getcontext\n * @template T\n * @param {any} key\n * @returns {T}\n */\nexport function getContext(key) {\n\tconst context_map = get_or_init_context_map();\n\treturn /** @type {T} */ (context_map.get(key));\n}\n\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#setcontext\n * @template T\n * @param {any} key\n * @param {T} context\n * @returns {T}\n */\nexport function setContext(key, context) {\n\tconst context_map = get_or_init_context_map();\n\tcontext_map.set(key, context);\n\treturn context;\n}\n\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#hascontext\n * @param {any} key\n * @returns {boolean}\n */\nexport function hasContext(key) {\n\tconst context_map = get_or_init_context_map();\n\treturn context_map.has(key);\n}\n\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs/svelte#getallcontexts\n * @template {Map<any, any>} [T=Map<any, any>]\n * @returns {T}\n */\nexport function getAllContexts() {\n\tconst context_map = get_or_init_context_map();\n\treturn /** @type {T} */ (context_map);\n}\n\n/**\n * @template [T=any]\n * @param {string} type\n * @param {T} [detail]\n * @param {any}params_0\n * @returns {CustomEvent<T>}\n */\nfunction create_custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n\treturn new CustomEvent(type, { detail, bubbles, cancelable });\n}\n\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:\n * ```ts\n * const dispatch = createEventDispatcher<{\n *  loaded: never; // does not take a detail argument\n *  change: string; // takes a detail argument of type string, which is required\n *  optional: number | null; // takes an optional detail argument of type number\n * }>();\n * ```\n *\n * https://svelte.dev/docs/svelte#createeventdispatcher\n * @template {Record<string, any>} [EventMap = any]\n * @returns {import('./public.js').EventDispatcher<EventMap>}\n */\nexport function createEventDispatcher() {\n\tconst component_context = current_component_context;\n\tif (component_context === null) {\n\t\tthrow new Error('createEventDispatcher can only be used during component initialisation.');\n\t}\n\n\treturn (type, detail, options) => {\n\t\tconst events = /** @type {Record<string, Function | Function[]>} */ (\n\t\t\tcomponent_context.s.$$events\n\t\t)?.[/** @type {any} */ (type)];\n\n\t\tif (events) {\n\t\t\tconst callbacks = is_array(events) ? events.slice() : [events];\n\t\t\t// TODO are there situations where events could be dispatched\n\t\t\t// in a server (non-DOM) environment?\n\t\t\tconst event = create_custom_event(/** @type {string} */ (type), detail, options);\n\t\t\tfor (const fn of callbacks) {\n\t\t\t\tfn.call(component_context.a, event);\n\t\t\t}\n\t\t\treturn !event.defaultPrevented;\n\t\t}\n\n\t\treturn true;\n\t};\n}\n\nfunction init_update_callbacks() {\n\tlet called_before = false;\n\tlet called_after = false;\n\n\t/** @type {NonNullable<import('../internal/client/types.js').ComponentContext['u']>} */\n\tconst update_callbacks = {\n\t\tb: [],\n\t\ta: [],\n\t\te() {\n\t\t\tif (!called_before) {\n\t\t\t\tcalled_before = true;\n\t\t\t\t// TODO somehow beforeUpdate ran twice on mount in Svelte 4 if it causes a render\n\t\t\t\t// possibly strategy to get this back if needed: analyse beforeUpdate function for assignements to state,\n\t\t\t\t// if yes, add a call to the component to force-run beforeUpdate once.\n\t\t\t\tuntrack(() => update_callbacks.b.forEach(/** @param {any} c */ (c) => c()));\n\t\t\t\tflush_local_render_effects();\n\t\t\t\t// beforeUpdate can run again once if afterUpdate causes another update,\n\t\t\t\t// but afterUpdate shouldn't be called again in that case to prevent infinite loops\n\t\t\t\tif (!called_after) {\n\t\t\t\t\tuser_effect(() => {\n\t\t\t\t\t\tcalled_before = false;\n\t\t\t\t\t\tcalled_after = true;\n\t\t\t\t\t\tuntrack(() => update_callbacks.a.forEach(/** @param {any} c */ (c) => c()));\n\t\t\t\t\t\t// managed_effect so that it's not cleaned up when the parent effect is cleaned up\n\t\t\t\t\t\tconst managed = managed_effect(() => {\n\t\t\t\t\t\t\tdestroy_signal(managed);\n\t\t\t\t\t\t\tcalled_after = false;\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tuser_effect(() => {\n\t\t\t\t\t\tcalled_before = false;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\treturn update_callbacks;\n}\n\n// TODO mark beforeUpdate and afterUpdate as deprecated in Svelte 6\n\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`.\n *\n * In runes mode use `$effect.pre` instead.\n *\n * https://svelte.dev/docs/svelte#beforeupdate\n * @deprecated Use `$effect.pre` instead — see https://svelte-5-preview.vercel.app/docs/deprecations#beforeupdate-and-afterupdate\n * @param {() => void} fn\n * @returns {void}\n */\nexport function beforeUpdate(fn) {\n\tconst component_context = current_component_context;\n\tif (component_context === null) {\n\t\tthrow new Error('beforeUpdate can only be used during component initialisation.');\n\t}\n\n\t(component_context.u ??= init_update_callbacks()).b.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`.\n *\n * In runes mode use `$effect` instead.\n *\n * https://svelte.dev/docs/svelte#afterupdate\n * @deprecated Use `$effect` instead — see https://svelte-5-preview.vercel.app/docs/deprecations#beforeupdate-and-afterupdate\n * @param {() => void} fn\n * @returns {void}\n */\nexport function afterUpdate(fn) {\n\tconst component_context = current_component_context;\n\tif (component_context === null) {\n\t\tthrow new Error('afterUpdate can only be used during component initialisation.');\n\t}\n\n\t(component_context.u ??= init_update_callbacks()).a.push(fn);\n}\n\n// TODO bring implementations in here\n// (except probably untrack — do we want to expose that, if there's also a rune?)\nexport {\n\tflushSync,\n\tcreateRoot,\n\tmount,\n\ttick,\n\tuntrack,\n\tunstate,\n\tonDestroy\n} from '../internal/index.js';\n"],
  "mappings": "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",
  "names": []
}
